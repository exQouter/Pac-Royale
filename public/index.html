<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Royale Final</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background: #050505; color: white; font-family: 'Press Start 2P'; display: flex; flex-direction: row; align-items: center; justify-content: center; height: 100vh; user-select: none; overflow: hidden; }
        
        /* UI LAYOUT */
        .ui-column { display: flex; flex-direction: column; gap: 20px; justify-content: center; height: 100%; margin: 0 15px; }
        .side-panel { width: 120px; height: 300px; background: #111; border: 3px solid #333; border-radius: 8px; padding: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; opacity: 0.3; transition: opacity 0.3s; box-shadow: 5px 5px 0px #000; }
        .side-panel.active { opacity: 1; border-color: #fff; box-shadow: 8px 8px 0px #000; transform: translate(-2px, -2px); }
        .pac-avatar { width: 40px; height: 40px; border-radius: 50%; margin-bottom: 10px; position: relative; box-shadow: 0 0 10px currentColor; border: 2px solid #fff; }
        .pac-avatar::after { content: ''; position: absolute; top: 20%; left: 50%; width: 60%; height: 30%; background: #111; clip-path: polygon(0 50%, 100% 0, 100% 100%); }
        .player-name-ui { font-size: 8px; margin-bottom: 10px; color: white; text-shadow: 1px 1px 0 #000; word-break: break-all; background: #333; padding: 5px; border-radius: 4px; width: 90%; }
        .stat-label { font-size: 7px; color: #888; margin-top: 10px; margin-bottom: 5px; }
        .score-box { font-size: 10px; color: #fff; }
        .lives-box { color: #ff3333; letter-spacing: 2px; font-size: 12px; }
        
        canvas { border: 6px solid #1919A6; background: black; image-rendering: pixelated; box-shadow: 0 0 40px rgba(25,25,166,0.4); display: none; }

        /* SCREENS */
        .screen { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: #000; padding: 40px; border: 4px solid #ffcc00; z-index: 100; min-width: 550px; box-shadow: 10px 10px 0px rgba(0,0,0,0.8); display: none; }
        .visible { display: block !important; }
        #countdown-display { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 100px; color: #ffcc00; text-shadow: 5px 5px 0 #000; z-index: 50; pointer-events: none; display: none; }

        /* CONTROLS */
        button { background: #ffcc00; padding: 15px; font-family: inherit; cursor: pointer; border: 2px solid white; margin-top: 15px; text-transform: uppercase; box-shadow: 4px 4px 0 #b8860b; width: 100%; font-weight: bold; font-size: 12px; box-sizing: border-box; }
        button:hover { transform: translate(-1px, -1px); background: #ffe066; }
        button:active { transform: translate(1px, 1px); box-shadow: 2px 2px 0 #b8860b; }
        button:disabled { background: #555; color: #888; cursor: not-allowed; box-shadow: none; transform: none; }
        input { background: #111; border: 2px solid #555; color: #ffcc00; font-family: inherit; padding: 15px; text-align: center; text-transform: uppercase; font-size: 16px; display: block; margin: 10px auto; width: 80%; box-sizing: border-box; }

        /* MENU ALIGNMENT */
        .menu-grid { display: grid; grid-template-columns: 1fr 2px 1fr; gap: 20px; margin-top: 20px; align-items: stretch; } 
        .menu-col { display: flex; flex-direction: column; gap: 10px; justify-content: space-between; }
        .menu-divider { background: #333; height: 100%; min-height: 150px; }
        .menu-label { font-size: 10px; color: #888; margin-bottom: 5px; text-align: center; }

        .lobby-container { display: flex; gap: 15px; justify-content: center; margin: 30px 0; }
        .lobby-slot { width: 100px; height: 140px; border: 4px solid #333; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; }
        .lobby-slot.filled { border-color: #fff; background: #111; }
        .slot-label { font-size: 8px; color: #666; position: absolute; top: 5px; }
        .slot-name { font-size: 10px; color: #fff; margin-top: 10px; word-break: break-all; }
        .slot-pacman { width: 50px; height: 50px; border-radius: 50%; position: relative; box-shadow: 0 0 10px currentColor; }
        .slot-pacman::after { content: ''; position: absolute; top: 20%; left: 50%; width: 60%; height: 30%; background: #000; clip-path: polygon(0 50%, 100% 0, 100% 100%); }
        .waiting-anim { font-size: 8px; color: #444; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }
        .lobby-code { font-size: 24px; color: #00FFFF; margin: 10px 0; cursor: pointer; border: 1px dashed #444; padding: 10px; }
        .error-msg { color: red; font-size: 10px; margin-top: 15px; text-align: center; }
        #scoreboard-btn { background: #444; color: white; font-size: 10px; width: 200px; margin: 20px auto; border-color: #666; box-shadow: none; display: block; }
        
        #global-ui { display: none !important; }
    </style>
</head>
<body>

    <div id="intro-screen" class="screen visible">
        <h1 style="color:#ffcc00; font-size:36px; margin-bottom:40px; text-shadow: 4px 4px 0 #b8860b;">PAC-ROYALE</h1>
        <p style="font-size:10px; color:#aaa; margin-bottom:20px;">ONLINE BATTLE</p>
        <button style="width: 200px; margin: 0 auto; display: block;" onclick="enterMenu()">PLAY</button>
        <button id="scoreboard-btn" onclick="toggleBoard(); uiClick()">üèÜ SCOREBOARD</button>
    </div>

    <div id="menu-screen" class="screen">
        <h2 style="color:#ffcc00; margin-bottom:10px;">SETUP PROFILE</h2>
        <div style="width: 80%; margin: 0 auto;">
             <input type="text" id="nickname" placeholder="ENTER NICKNAME" maxlength="10">
        </div>
        <div class="menu-grid">
            <div class="menu-col">
                <div class="menu-label">NEW GAME</div>
                <button onclick="createLobby(); uiClick()">CREATE LOBBY</button>
            </div>
            <div class="menu-divider"></div>
            <div class="menu-col">
                <div class="menu-label">EXISTING GAME</div>
                <div style="display: flex; flex-direction: column; gap: 5px; width: 100%;">
                    <input type="text" id="lobby-code-input" placeholder="CODE" maxlength="5" style="width: 100%;">
                    <button onclick="joinLobby(); uiClick()">JOIN</button>
                </div>
            </div>
        </div>
        <div id="menu-error" class="error-msg"></div>
        <button style="background: #444; border-color: #666; margin-top:30px; width:auto;" onclick="backToIntro(); uiClick()">BACK</button>
    </div>

    <div id="lobby-screen" class="screen" style="min-width: 600px;">
        <h2 style="font-size:16px; color:#aaa;">LOBBY ROOM</h2>
        <div class="lobby-code" id="lobby-code-display" onclick="copyLink(); uiClick()">CODE: ????</div>
        <div style="font-size:8px; color:#666; margin-bottom:20px;">(CLICK CODE TO COPY INVITE LINK)</div>
        <div class="lobby-container">
            <div class="lobby-slot" id="slot-0"><div class="slot-label">PLAYER 1</div><div class="waiting-anim">WAITING...</div></div>
            <div class="lobby-slot" id="slot-1"><div class="slot-label">PLAYER 2</div><div class="waiting-anim">WAITING...</div></div>
            <div class="lobby-slot" id="slot-2"><div class="slot-label">PLAYER 3</div><div class="waiting-anim">WAITING...</div></div>
            <div class="lobby-slot" id="slot-3"><div class="slot-label">PLAYER 4</div><div class="waiting-anim">WAITING...</div></div>
        </div>
        <div style="width: 50%; margin: 0 auto;">
            <button id="start-game-btn" onclick="startGame(); uiClick()" style="display:none; background:#00FF00; color:black;">START GAME</button>
        </div>
        <div id="waiting-msg" style="font-size:10px; color:#FFFF00; margin-top:20px;">WAITING FOR HOST...</div>
    </div>

    <div id="board-screen" class="screen">
        <h1 style="color:#ffcc00;">TOP 10</h1>
        <table id="board-table" style="width:100%; color:#ccc; font-size:10px; margin-top:20px;"></table>
        <button onclick="toggleBoard(); uiClick()">CLOSE</button>
    </div>

    <div id="countdown-display">3</div>

    <div class="ui-column">
        <div class="side-panel" id="p0"><div class="pac-avatar" style="background:#FFFF00; color:#FFFF00"></div><div class="player-name-ui" id="n0">P1</div><div class="stat-label">SCORE</div><div class="score-box" id="s0">0</div><div class="stat-label">LIVES</div><div class="lives-box" id="l0">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div></div>
        <div class="side-panel" id="p2"><div class="pac-avatar" style="background:#00FFFF; color:#00FFFF"></div><div class="player-name-ui" id="n2">P3</div><div class="stat-label">SCORE</div><div class="score-box" id="s2">0</div><div class="stat-label">LIVES</div><div class="lives-box" id="l2">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div></div>
    </div>
    <canvas id="gameCanvas" width="600" height="800"></canvas>
    <div class="ui-column">
        <div class="side-panel" id="p1"><div class="pac-avatar" style="background:#00FF00; color:#00FF00"></div><div class="player-name-ui" id="n1">P2</div><div class="stat-label">SCORE</div><div class="score-box" id="s1">0</div><div class="stat-label">LIVES</div><div class="lives-box" id="l1">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div></div>
        <div class="side-panel" id="p3"><div class="pac-avatar" style="background:#FF00FF; color:#FF00FF"></div><div class="player-name-ui" id="n3">P4</div><div class="stat-label">SCORE</div><div class="score-box" id="s3">0</div><div class="stat-label">LIVES</div><div class="lives-box" id="l3">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div></div>
    </div>

    <div id="game-over" class="screen">
        <h1 style="color:red;">GAME OVER</h1>
        <p id="final-score" style="color:white; font-size:14px; margin:20px 0;"></p>
        <button onclick="submitScore(); uiClick()">SUBMIT</button>
    </div>
    <div id="host-left-screen" class="screen" style="z-index:200;">
        <h1 style="color:red;">ROOM CLOSED</h1>
        <button onclick="location.reload()" style="width: 200px; margin: 0 auto;">MENU</button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const TILE_SIZE = 30;
        const urlParams = new URLSearchParams(window.location.search);
        
        let isJoined = false;
        let popups = [];
        let prevScore = 0;
        let lastAngles = {};
        let leaderboardData = []; 
        let deathZoneY = 1000;

        if(urlParams.has('code')) document.getElementById('lobby-code-input').value = urlParams.get('code');

        // --- –°–ò–ù–¢–ï–ó–ê–¢–û–† (Soft & Smooth Version) ---
        class PacmanSynth {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.15; 
                this.masterGain.connect(this.ctx.destination);
                this.sirenOsc = null; 
            }
            resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }
            
            createSoftOscillator(type, freq, startTime) {
                const osc = this.ctx.createOscillator();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, startTime);
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000; 
                const gain = this.ctx.createGain();
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                return { osc, gain };
            }

            playClick() {
                const t = this.ctx.currentTime;
                const { osc, gain } = this.createSoftOscillator('square', 800, t);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.start(t); osc.stop(t + 0.1);
            }

            playWaka() {
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                osc.type = 'sine'; 
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.15); 
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.8, t + 0.02); 
                gain.gain.linearRampToValueAtTime(0, t + 0.15); 
                osc.connect(gain); gain.connect(this.masterGain);
                osc.start(t); osc.stop(t + 0.15);
            }

            playEat() {
                const t = this.ctx.currentTime;
                const { osc, gain } = this.createSoftOscillator('square', 300, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.1);
                osc.start(t); osc.stop(t + 0.1);
            }

            playDeath() {
                this.stopSiren();
                const t = this.ctx.currentTime;
                for(let i=0; i<8; i++) {
                    const { osc, gain } = this.createSoftOscillator('triangle', 300 - i*30, t + i*0.1);
                    osc.frequency.linearRampToValueAtTime(50, t + i*0.1 + 0.1);
                    gain.gain.setValueAtTime(0.3, t + i*0.1);
                    gain.gain.linearRampToValueAtTime(0, t + i*0.1 + 0.1);
                    osc.start(t + i*0.1); osc.stop(t + i*0.1 + 0.1);
                }
            }

            playIntro() {
                const t = this.ctx.currentTime;
                const notes = [246, 493, 369, 311, 493, 369, 311, 493, 369, 311, 246];
                let time = t;
                notes.forEach(freq => {
                    const { osc, gain } = this.createSoftOscillator('triangle', freq, time);
                    gain.gain.setValueAtTime(0.2, time);
                    gain.gain.linearRampToValueAtTime(0, time + 0.08);
                    osc.start(time); osc.stop(time + 0.1);
                    time += 0.12;
                });
            }

            startSiren(type) {
                if (this.sirenOsc) return;
                const t = this.ctx.currentTime;
                this.sirenOsc = this.ctx.createOscillator();
                this.sirenOsc.type = type === 'power' ? 'triangle' : 'sine';
                const baseFreq = type === 'power' ? 300 : 150;
                this.sirenOsc.frequency.setValueAtTime(baseFreq, t);
                const lfo = this.ctx.createOscillator();
                lfo.frequency.value = type === 'power' ? 5 : 1.5;
                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 20; 
                lfo.connect(lfoGain); lfoGain.connect(this.sirenOsc.frequency);
                lfo.start(t);
                const mainGain = this.ctx.createGain();
                mainGain.gain.value = 0.1; 
                this.sirenOsc.connect(mainGain); mainGain.connect(this.masterGain);
                this.sirenOsc.start(t);
                this.sirenLFO = lfo;
                this.currentSirenType = type;
            }

            stopSiren() {
                if (this.sirenOsc) { try { this.sirenOsc.stop(); if(this.sirenLFO) this.sirenLFO.stop(); } catch(e){} this.sirenOsc = null; }
                this.currentSirenType = null;
            }
            
            checkSirenUpdate(newType) {
                if (this.sirenOsc && this.currentSirenType !== newType) {
                    this.stopSiren();
                    this.startSiren(newType);
                } else if (!this.sirenOsc) {
                    this.startSiren(newType);
                }
            }
        }
        const synth = new PacmanSynth();

        // --- UI –§–£–ù–ö–¶–ò–ò ---
        function uiClick() { synth.resume(); synth.playClick(); }
        function enterMenu() {
            synth.resume(); synth.playClick(); 
            document.getElementById('intro-screen').classList.remove('visible');
            document.getElementById('menu-screen').classList.add('visible');
        }
        function backToIntro() {
            document.getElementById('menu-screen').classList.remove('visible');
            document.getElementById('intro-screen').classList.add('visible');
            synth.stopSiren();
        }
        function getNick() { return document.getElementById('nickname').value.trim() || "PLAYER"; }
        function createLobby() { socket.emit('createLobby', { nickname: getNick() }); }
        function joinLobby() { const c = document.getElementById('lobby-code-input').value.trim(); if(!c) { showErr('ENTER CODE'); return; } socket.emit('joinLobby', { code: c, nickname: getNick() }); }
        function startGame() { socket.emit('startGame'); }
        function showErr(msg) { document.getElementById('menu-error').innerText = msg; }
        function copyLink() { navigator.clipboard.writeText(window.location.origin + "/?code=" + document.getElementById('lobby-code-display').innerText.split(': ')[1]); alert("Link copied!"); }
        
        function toggleBoard() {
            const el = document.getElementById('board-screen');
            const intro = document.getElementById('intro-screen');
            if(el.classList.contains('visible')) { el.classList.remove('visible'); intro.classList.add('visible'); }
            else { intro.classList.remove('visible'); el.classList.add('visible'); renderBoard(); }
        }
        function renderBoard() {
            const t = document.getElementById('board-table'); 
            t.innerHTML = '<tr><th>RANK</th><th>NAME</th><th>SCORE</th></tr>';
            if(leaderboardData && leaderboardData.length > 0) {
                leaderboardData.forEach((r,i) => t.innerHTML += `<tr><td style="color:${i===0?'#FFFF00':'#ccc'}">${i+1}ST</td><td>${r.name}</td><td>${r.score}</td></tr>`);
            } else {
                t.innerHTML += '<tr><td colspan="3">NO RECORDS YET</td></tr>';
            }
        }
        function renderLobbySlots(players) {
            for(let i=0; i<4; i++) {
                const slot = document.getElementById(`slot-${i}`);
                slot.className = 'lobby-slot'; 
                slot.innerHTML = `<div class="slot-label">PLAYER ${i+1}</div><div class="waiting-anim">WAITING...</div>`;
            }
            players.forEach(p => {
                const slot = document.getElementById(`slot-${p.colorIdx}`);
                if(slot) {
                    slot.classList.add('filled');
                    slot.innerHTML = `<div class="slot-label" style="color:${p.color}">PLAYER ${p.colorIdx+1}</div><div class="slot-pacman" style="background:${p.color}; color:${p.color}; box-shadow: 0 0 15px ${p.color}"></div><div class="slot-name">${p.name}</div>`;
                }
            });
        }
        function submitScore() {
            const name = getNick();
            let scoreTxt = document.getElementById('final-score').innerText.split(': ')[1];
            socket.emit('submitScore', {name: name, score: parseInt(scoreTxt) || 0});
            location.reload();
        }

        // --- SOCKET ---
        socket.on('lobbyUpdate', d => {
            document.getElementById('menu-screen').classList.remove('visible');
            document.getElementById('lobby-screen').classList.add('visible');
            document.getElementById('lobby-code-display').innerText = `CODE: ${d.roomId}`;
            renderLobbySlots(d.players);
            if(socket.id === d.hostId) { document.getElementById('start-game-btn').style.display = 'block'; document.getElementById('waiting-msg').style.display = 'none'; }
            else { document.getElementById('start-game-btn').style.display = 'none'; document.getElementById('waiting-msg').style.display = 'block'; }
        });

        socket.on('errorMsg', msg => showErr(msg));
        socket.on('roomClosed', () => { document.querySelectorAll('.screen').forEach(s => s.classList.remove('visible')); document.getElementById('host-left-screen').classList.add('visible'); synth.stopSiren(); });
        
        socket.on('gameStarted', () => { 
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('visible'));
            canvas.style.display = 'block'; 
            isJoined = true; 
            synth.playIntro(); 
            setTimeout(() => { if(isJoined) synth.startSiren('normal'); }, 4000); 
        });

        socket.on('sfx', t => { 
            if(!isJoined) return; 
            if (t === 'waka') synth.playWaka();
            else if (t === 'eatGhost' || t === 'eatFruit') synth.playEat();
            else if (t === 'death') synth.playDeath();
            else if (t === 'power') synth.startSiren('power');
        });

        socket.on('popup', p => popups.push({x: p.x, y: p.y, text: p.text, life: 60, color: p.color}));
        socket.on('gameOver', s => { 
            document.getElementById('game-over').classList.add('visible'); 
            document.getElementById('final-score').innerText = "SCORE: " + s; 
            synth.stopSiren();
        });
        socket.on('leaderboardUpdate', d => leaderboardData = d);
        
        document.addEventListener('keydown', e => { 
            if(!isJoined) return; 
            let d=null; 
            if(e.code==='ArrowUp'||e.code==='KeyW') { d={x:0,y:-1}; e.preventDefault(); }
            if(e.code==='ArrowDown'||e.code==='KeyS') { d={x:0,y:1}; e.preventDefault(); }
            if(e.code==='ArrowLeft'||e.code==='KeyA') { d={x:-1,y:0}; e.preventDefault(); }
            if(e.code==='ArrowRight'||e.code==='KeyD') { d={x:1,y:0}; e.preventDefault(); }
            if(d) socket.emit('input', d); 
        });

        function drawGhost(ctx, x, y, color, vx, vy, frightenedTimer) {
            const cx = x + TILE_SIZE/2;
            const cy = y + TILE_SIZE/2;
            let bodyColor = color;
            let isScared = frightenedTimer > 0;

            // –õ–û–ì–ò–ö–ê –¶–í–ï–¢–ê (–°–ò–ù–ò–ô / –ú–ò–ì–ê–Æ–©–ò–ô)
            if (isScared) {
                // –ú–∏–≥–∞–Ω–∏–µ –≤ –∫–æ–Ω—Ü–µ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 2 —Å–µ–∫—É–Ω–¥—ã)
                if (frightenedTimer < 120 && Math.floor(Date.now() / 200) % 2 === 0) {
                    bodyColor = '#FFFFFF';
                } else {
                    bodyColor = '#1919A6';
                }
            }

            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.arc(cx, cy - 2, 13, Math.PI, 0);
            ctx.lineTo(cx + 13, cy + 13);

            // –ù–æ–≥–∏ / –ó–∏–≥–∑–∞–≥
            if (isScared) {
                const waveWidth = 6;
                for (let i = 1; i <= 4; i++) {
                    ctx.lineTo(cx + 13 - waveWidth * i + waveWidth/2, cy + 10);
                    ctx.lineTo(cx + 13 - waveWidth * i, cy + 13);
                }
            } else {
                for(let i=1; i<=3; i++) {
                    ctx.lineTo(cx + 13 - 26/3*i + 26/6, cy + 10);
                    ctx.lineTo(cx + 13 - 26/3*i, cy + 13);
                }
            }
            ctx.lineTo(cx - 13, cy - 2);
            ctx.fill();

            // –õ–ò–¶–û
            if (isScared) {
                const faceColor = (bodyColor === '#FFFFFF') ? '#FF0000' : '#FFB8FF';
                ctx.fillStyle = faceColor;
                // –ì–ª–∞–∑–∞
                ctx.fillRect(cx - 5, cy - 2, 2, 2);
                ctx.fillRect(cx + 3, cy - 2, 2, 2);
                // –†–æ—Ç (–∑–∏–≥–∑–∞–≥)
                ctx.strokeStyle = faceColor;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(cx - 10, cy + 5);
                ctx.lineTo(cx - 6, cy + 2);
                ctx.lineTo(cx - 2, cy + 5);
                ctx.lineTo(cx + 2, cy + 2);
                ctx.lineTo(cx + 6, cy + 5);
                ctx.lineTo(cx + 10, cy + 2);
                ctx.stroke();
            } else {
                // –û–±—ã—á–Ω–æ–µ –ª–∏—Ü–æ
                let px = vx > 0 ? 2 : (vx < 0 ? -2 : 0);
                let py = vy > 0 ? 2 : (vy < 0 ? -2 : 0);
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(cx - 4, cy - 4, 4, 0, Math.PI * 2);
                ctx.arc(cx + 4, cy - 4, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'blue';
                ctx.beginPath();
                ctx.arc(cx - 4 + px, cy - 4 + py, 2, 0, Math.PI * 2);
                ctx.arc(cx + 4 + px, cy - 4 + py, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        socket.on('state', s => {
            if(!isJoined) return;
            const cdEl = document.getElementById('countdown-display');
            if (s.countdown > 0) { cdEl.style.display = 'block'; cdEl.innerText = Math.ceil(s.countdown); } 
            else if (s.countdown > -1) { cdEl.style.display = 'block'; cdEl.innerText = "GO!"; } 
            else { cdEl.style.display = 'none'; }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º—É–∑—ã–∫–∏
            if (Date.now() - (s.startTime || 0) > 4000 || s.countdown < 0) {
                if(s.frightenedTimer > 0) synth.checkSirenUpdate('power');
                else synth.checkSirenUpdate('normal');
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const camY = s.cameraY;
            const startRow = Math.floor(camY / TILE_SIZE) - 2;
            const endRow = startRow + (canvas.height / TILE_SIZE) + 4;

            // –†–ò–°–û–í–ê–ù–ò–ï –ö–ê–†–¢–´
            for (let y = startRow; y <= endRow; y++) {
                if (!s.rows[y]) continue;
                const sy = (y * TILE_SIZE - camY) | 0;
                for (let x = 0; x < 20; x++) {
                    const t = s.rows[y][x]; const sx = x * TILE_SIZE;
                    
                    if (t === 1) { // WALL
                        ctx.fillStyle = '#1919A6';
                        ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
                        ctx.fillStyle = 'black';
                        ctx.fillRect(sx + 4, sy + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                        if (x < 19 && s.rows[y][x+1] === 1) ctx.fillRect(sx + TILE_SIZE - 4, sy + 4, 8, TILE_SIZE - 8);
                        if (x > 0 && s.rows[y][x-1] === 1) ctx.fillRect(sx - 4, sy + 4, 8, TILE_SIZE - 8);
                        if (s.rows[y+1] && s.rows[y+1][x] === 1) ctx.fillRect(sx + 4, sy + TILE_SIZE - 4, TILE_SIZE - 8, 8);
                        if (s.rows[y-1] && s.rows[y-1][x] === 1) ctx.fillRect(sx + 4, sy - 4, TILE_SIZE - 8, 8);
                    } else if (t === 2) { 
                        ctx.fillStyle = '#ffb8ae'; ctx.fillRect(sx+13, sy+13, 4, 4);
                    } else if (t === 3) { 
                        ctx.fillStyle = (Date.now()%400 < 200) ? '#fff' : '#ffb8ae'; ctx.beginPath(); ctx.arc(sx+15, sy+15, 8, 0, Math.PI*2); ctx.fill();
                    } else if (t === 4) { 
                        ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(sx+15, sy+18, 6, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#00ff00'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(sx+15, sy+18); ctx.quadraticCurveTo(sx+20, sy+10, sx+22, sy+8); ctx.stroke();
                    } else if (t === 5) { 
                        ctx.fillStyle = '#9900ff'; ctx.beginPath(); ctx.arc(sx+15, sy+15, 8, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(sx+12, sy+13, 2, 0, Math.PI*2); ctx.arc(sx+18, sy+13, 2, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = 'black'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(sx+12, sy+18); ctx.lineTo(sx+18, sy+18); ctx.stroke();
                    } else if (t === 6) { 
                        ctx.fillStyle = '#ff3333'; ctx.beginPath(); ctx.moveTo(sx+15, sy+10); ctx.bezierCurveTo(sx+15, sy+8, sx+12, sy+5, sx+8, sy+5); ctx.bezierCurveTo(sx+2, sy+5, sx+2, sy+14, sx+15, sy+22); ctx.bezierCurveTo(sx+28, sy+14, sx+28, sy+5, sx+22, sy+5); ctx.bezierCurveTo(sx+18, sy+5, sx+15, sy+8, sx+15, sy+10); ctx.fill();
                    }
                }
            }

            // –†–ò–°–û–í–ê–ù–ò–ï –ü–†–ò–ó–†–ê–ö–û–í –° –ê–ù–ò–ú–ê–¶–ò–ï–ô –°–ú–ï–†–¢–ò
            s.ghosts.forEach(g => drawGhost(ctx, g.x, g.y - camY, g.color, g.vx, g.vy, s.frightenedTimer));
            
            for(let i=0; i<4; i++) document.getElementById(`p${i}`).classList.remove('active');
            for(let id in s.players) {
                const p = s.players[id];
                const panel = document.getElementById(`p${p.colorIdx}`);
                if(panel) {
                    panel.classList.add('active'); panel.style.opacity = 1;
                    document.getElementById(`n${p.colorIdx}`).innerText = p.name;
                    document.getElementById(`s${p.colorIdx}`).innerText = p.score;
                    document.getElementById(`l${p.colorIdx}`).innerText = p.alive ? "‚ù§Ô∏è".repeat(p.lives) : "DEAD";
                }
                if(p.id === socket.id && p.score > prevScore) { synth.playWaka(); prevScore = p.score; }
                if(!p.alive) continue;
                const sy = p.y - camY;
                
                // –ê–Ω–∏–º–∞—Ü–∏—è —Å–º–µ—Ä—Ç–∏ –∏–≥—Ä–æ–∫–∞
                if (p.deathTimer > 0) {
                    // –°—Ö–ª–æ–ø—ã–≤–∞–Ω–∏–µ —Ä—Ç–∞ (–ü–∞–∫–º–∞–Ω-—Å–º–µ—Ä—Ç—å)
                    const progress = 1 - (p.deathTimer / 60); // –æ—Ç 0 –¥–æ 1
                    const startAngle = -Math.PI/2 + (progress * Math.PI);
                    const endAngle = -Math.PI/2 + (2*Math.PI - progress * Math.PI);
                    
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.moveTo(p.x + 15, sy + 15);
                    ctx.arc(p.x + 15, sy + 15, 12, startAngle, endAngle);
                    ctx.fill();
                    continue;
                }

                if(p.invulnTimer > 0 && Date.now()%200 < 100) continue;
                ctx.fillStyle = (p.pvpTimer > 0) ? '#9900FF' : p.color; 
                ctx.beginPath();
                if(p.vx > 0) lastAngles[id] = 0; else if(p.vy > 0) lastAngles[id] = Math.PI/2; else if(p.vx < 0) lastAngles[id] = Math.PI; else if(p.vy < 0) lastAngles[id] = -Math.PI/2;
                const angle = lastAngles[id] !== undefined ? lastAngles[id] : 0;
                const mouth = 0.2 + (Math.sin(Date.now()/50)+1)/10;
                ctx.arc(p.x+15, sy+15, 12, angle + mouth*Math.PI, angle + (2-mouth)*Math.PI); ctx.lineTo(p.x+15, sy+15); ctx.fill();
                ctx.fillStyle = "white"; ctx.font = "8px 'Press Start 2P'"; ctx.textAlign="center"; ctx.fillText(p.name, p.x+15, sy-5);
            }
            popups = popups.filter(p => p.life > 0);
            popups.forEach(p => {
                p.life--; p.y -= 1; ctx.fillStyle = p.color || '#00FFFF'; ctx.font = "10px 'Press Start 2P'"; ctx.fillText(p.text, p.x+15, p.y - camY);
            });
            const targetY = canvas.height - 40;
            if(s.countdown > 0) { deathZoneY = canvas.height + 100; } else { deathZoneY += (targetY - deathZoneY) * 0.02; }
            const time = Date.now()/200;
            const gCols = ['#FF0000', '#FFB8FF', '#00FFFF', '#FFB852'];
            for(let i=-1; i<22; i++) { const waveY = Math.sin(time + i*0.5)*5; drawGhost(ctx, i*30, deathZoneY + waveY, gCols[i%4], 0, -1, 0); }
            for(let i=-1; i<22; i++) { const waveY = Math.sin(time + i*0.5 + 2)*5; drawGhost(ctx, i*30-15, deathZoneY + 15 + waveY, gCols[(i+2)%4], 0, -1, 0); }
        });
    </script>
</body>
</html>